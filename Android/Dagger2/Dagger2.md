# Dagger2

> ### 参考文章[Dagger2 入门,以初学者角度.](http://www.jianshu.com/p/1d84ba23f4d2)

#### 1. Dagger2的三个模块

- 依赖提供方Module

    - 负责提供以来中所需要的对象.实际编码中类似于工厂类.

- 依赖需求方实例

    - 声明依赖对象,在实际编码中对应业务类.

- 依赖注入组件Component

    - 负责将对象注入到依赖需求放,在实际编码中是一个接口.

#### 2. Dagger2的工作流程

- 将依赖需求方实例差un如给Component实现类.

- Component实现类根据依赖需求方实例中依赖声明,确定该实例需要依赖哪些对象.

- 确定依赖对象之后,Component会在于自己关联的Module类中查找有没有提供这些依赖对象的方法,如果有的话就将Module类中提供的依赖设置到依赖需求方实例中.

#### 3. 提供依赖的方式

- 将构造函数用@Inject标注

- 在Module里提供依赖.

    ---

    Dagger选择依赖提供的过程:

    - 查找Module中是否存在创建该类的方法

        - 若存在

            1. 若该方法存在参数,则按照步骤1依次初始化每个参数.

            2. 若不存在参数,直接初始化该类实例,一次依赖注入结束.

        - 若不存在,则查找@Inject标注的构造函数

            1. 构造函数存在参数,按照步骤1依次初始化每个参数.

            2. 构造函数不存在,直接初始化该类实例,一次依赖注入结束.
---

#### 4. @Named和@Qulifier注解

- @Named

    - 继承@Qulifier,可在参数中添加名称.用于指定待注入的对象调用的依赖方法.

- @Qulifier

    - 需要自定义注解.方法同@Name一样.解决依赖迷失问题.

        - 如果提供依赖的Module中有两个返回值一样的Provider,Dagger就不知道该用哪个方法.
---

#### 5. @Scope注解

- 声明作用域,与@Qulifier一样,需要自定义注解.

- @Singleton注解

    - 继承自@Scope,用于实现单例.

